# 1) 변수

### 1. var(재선언O, 재할당O)

- 변수 선언 방식에 큰 단점
- 변수를 다시 선언했음에도 에러가 나오지 않고 각기 다른 값이 출력됨

```javascript
var name = 'hw'
console.log(name) //hw

var name = 'javascript'
console.log(name) //javascript
```

- 유연한 변순선언으로 간단한 테스트에는 편리 **BUT** 코드량이 많아질수록 파악 힘듬



## immutable불변

### 2. let(재선언X, 재할당O)

```javascript
let name = 'hw'
console.log(name) //hw

let name = 'javascript'
console.log(name)
// Uncaught SyntaxError: Identifier 'name' has already been declared

name = 'react'
console.log(name) //react
```

- 변수 재선언은 되지 않으나 재할당이 가능하다.

### 3. const(재선언X, 재할당X)

- 객체나 배열의 요소 수정의 경우에선 재할당이 가능하다.

```javascript
const name = 'hw'
console.log(name) //hw

const name = 'javascript'
console.log(name)
// Uncaught SyntaxError: Identifier 'name' has already been declared

name = 'react'
console.log(name)
//Uncaught TypeError: Assignment to constant variable.
```

- 객체나 배열

```javascript
//object
const drinks = {};
drinks.caffe = 'latte';
drinks.lemon = 'ade';

console.log(drinks)
// {caffe:'latte', lemon: 'ade'}

// array
const arr = [1,2,3,4,5];
arr[0] = 100;
arr[4] = 500;
console.log(arr)
// [100,2,3,4,500]
```



# 2) String Literal

> 문자열과 변수들을 편하게 다룰 수 있게 도와주는 문법

```javascript
// 예전 사용방법(String Literal X)
const val01 = 'Hello';
const val02 = 'World';
const val03 = val01 + ' ' + val02 + '!!!!';
console.log(val03);// Hello World!!!!

// String Literal : `${variable}`

const litVal = `${val01} ${val02}!!!!`
console.log(litVal); //Hello World!!!!
```



# 3) 반복문(for ... of)

> 모든객체를 상대로 사용할 수 있는 것은 아님

- value값이 생기면 key값이 생기는 배열같은 객체여야만 사용 가능
- iterator(반복자) 객체를 반환하지 않는 객체를 만들었다면 사용 불가능

```javascript
let array = [10, 20, 30, 40];
// for... in..
for (let val in array) {
    console.log(val);
}
//0
//1
//2
//3
for (let val in array) {
    console.log(array[val]);
}
//10
//20
//30
//40

// for... of..
for (let val of array) {
    console.log(val);
}
//10
//20
//30
//40

let obj = {
    a: 1,
    b: 2,
    c: 3
}
// 불가능 예시
for (let obj of array) {
    console.log(val);
}
//error
// 이럴때는 for ... in..을 사용
for (let obj in array) {
    console.log(val);
}
//a
//b
//c
```



# 4) Rest Operator

> 함수의 마지막 파라미터의 앞에 ...를 붙여 함수에 전달된 나머지 인자를 배열로 대체해주는 기능

```javascript
function f (a, b, ...c){
    //여기서 ...이 Rest Operator이다
}

function printNums(num1, num2){
    console.log(num1, num2);
}
printNums(1,2,3,4,5); // 1 2

function printNums(num1, num2){
    console.log(arguments);
}
printNums(1,2,3,4,5);
//[Arguments] {'0':1, '1':2, '2':3, '3':4, '4':5}

function printNums(num1, ...num2){
    console.log(num1, num2);
}
printNums(1,2,3,4,5); //1 [2, 3, 4, 5]
```



# 5) Spread Operator

> 함수를 호출 할 때 인수로 사용할 수도 있고, 배열안에 들어갈 수도 있고, 객체 안에 들어갈 수도 있음.

- Rest Operator와 달리 함수를 호출할 때 사용하기 때문에 중간에 낑겨있어도 가능!

1. 함수를 호출 할 때 인수로 사용

```javascript
// 첫번째 경우
function sum (x, y, z) {
    return x+y+z;
}
console.log(sum(1,2,3)); // 6
// 배열의 요소를 사용하려 할 때
let arr = [10, 20, 30];
console.log(sum(arr)); // 10,20,30undefinedundefined
// 배열의 요소들을 함수의 인수로 사용할 수 없다.
// 사용하려면 apply를 이용!
console.log(sum.apply(null, arr)); //60
// 더 편한 방법이 Spread Operator
console.log(sum(...arr));//60

// 활용!
function sum(a, b, c, d, e) {
    return a+b+c+d+e;
}

let arr = [20, 30];
console.log(
	sum(10, ...arr, 40, 50)
)//150
```



- 배열안에서 쓰이는 방법

```javascript
// 1. 새로운 배열을 생성할 때 이미 존재하는 배열을 엘리먼트로 가지도록 하고 싶을 때
let face = ['eyes', 'nose', 'mouth']
let head = ['hair', ...face, 'ears']
console.log(head)
// ['hair', 'eyes', 'nose', 'mouth', 'ears']

// 2. 배열을 복사 할 때
let arr = [1,2,3]
let arrCpy=[...arr];
console.log(arrCpy) 
//[1,2,3] 깊은복사로 복사된 객체를 수정하여도 원래의 요소가 변경되지 않음
let arrCpy=arr; 
// [1,2,3]으로 같지만 얕은복사이기 때문에 복사된 객체를 수정할 경우 원래의 요소가 변경됨
```



- 객체안에서 쓰이는 방법

```javascript
let drinks = {
    caffe: 'latte',
    coca: 'cola'
}
// 그냥 할 경우
let newDrinks ={
    lemon: 'tea',
    orange: 'juice',
    drinks
}
console.log(newDrinks)
// {lemon:'tea', orange:'juice', drinks:{caffe:'latte', coca: 'cola'}}

// spread operator사용
let newDrinks ={
    lemon: 'tea',
    orange: 'juice',
    ...drinks
}
console.log(newDrinks)
// {lemon:'tea', orange:'juice', caffe:'latte', coca: 'cola'}
```





# 6) Arrow Function(화살표 함수)

> 1.  표현식의 결과값을 반환하는 표현식 본문에 사용
> 2.  상태블럭 본문에 사용

- 표현식의 결과값을 반환하는 표현식 본문에 사용

```javascript
let arr = [1, 2, 3, 4, 5];
// 원래 방식
let twice = arr.map(function(val){
    return val*2;
})
// 화살표 함수
let twice = arr.map(v=>v*2);
console.log(twice) //[2, 4, 6, 8, 10]
```

- 상태블럭 본문에 사용

```javascript
// example 1
let arr = [1, 2, 3, 4, 5];
let twice = arr.map(v=>{
    if (v % 2 === 0) {
        console.log('even number')
    } else {
        console.log('odd number')
    }
});
console.log(twice)
//odd number
//even number
//odd number
//even number
//odd number

// example 2
// map의 첫번째 인자는 배열의 값,  두번째 인자는 배열의 인덱스 값
let arr = [10, 20, 30, 40, 50];
let twice = arr.map((v, i)=>{
    console.log(`i: ${i}, v: ${v}`)
});
console.log(twice)
// i:0, v:10
// i:1, v:20
// i:2, v:30
// i:3, v:40
// i:4, v:50
```



# 7) Class

> 인스턴스 : class를 구성하기 위한 껍데기
>
> constructor :  class인스턴스를 생성하고 생성한 인스턴스를 초기화하는 역할

```javascript
class Person {
    constructor(region_, gender_){
        this.region = region_;
        this.gender = gender_;
    }
    greetings(val = 'an-nyeong') {
        console.log(val);
    }
}
// new연산자가 constructor를 호출하면서 파라미터를 전달해주고 초기값으로 세팅되는 것
let korean = new Person('Korea', 'male')
console.log(korean) // Person { region:'Korea', gender: 'male' }
korean.gender = 'female';
console.log(korean) // Person { region:'Korea', gender: 'female' }
koreand.greetins(); // an-nyeong

// 상속
class American extends Person {
    constructor(region_, gender_, language_){
        // super로 감싸져 있는 아이들은 부모클래스에 있는 초기화 룰을 따르겠다.
        // 따라서 상속받은 자식클래스에서 추가한 프로퍼티에 대해서만 초기화가 필요!
        super(region_, gender_)
        this.language = language_;
    }
    greetings(val = 'hello') {
        console.log(val);
    }
}
let american = new American('USA', 'female', 'English')
console.log(american);
// American { region:'USA', gender: 'female', language: 'English'}

american.greetings(); // 함수는 오버라이드되는것을 알 수 있다.
// hello
```

